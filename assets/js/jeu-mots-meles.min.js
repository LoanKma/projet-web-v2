let CURRENT_USER_ID = "guest";
async function initSession() {
  try {
    const response = await fetch("api/get_user.php");
    const data = await response.json();
    CURRENT_USER_ID = data.userId;
  } catch (e) {
    CURRENT_USER_ID = "guest";
  }
}
if (typeof showPopup !== "function") {
  (function () {
    const s = document.createElement("script");
    s.src = "assets/js/main.js";
    s.async = !0;
    document.head.appendChild(s);
  })();
}
const MOTS_MELES_LEVELS = {
  1: {
    theme: "Animaux de la ferme",
    difficulty: "easy",
    gridSize: 8,
    words: ["VACHE", "COCHON", "POULE", "ANE", "CHEVAL", "MOUTON"],
  },
  2: {
    theme: "Fruits d'√©t√©",
    difficulty: "easy",
    gridSize: 8,
    words: ["MELON", "FRAISE", "PECHE", "CASSIS", "MURE", "POIRE"],
  },
  3: {
    theme: "Couleurs",
    difficulty: "easy",
    gridSize: 8,
    words: ["ROUGE", "BLEU", "VERT", "JAUNE", "NOIR", "BLANC", "ROSE"],
  },
  4: {
    theme: "V√™tements",
    difficulty: "easy",
    gridSize: 8,
    words: ["ROBE", "JUPE", "PULL", "VESTE", "JEAN", "SHORT"],
  },
  5: {
    theme: "√âcole",
    difficulty: "easy",
    gridSize: 8,
    words: ["STYLO", "GOMME", "LIVRE", "CAHIER", "COLLE", "CRAIE", "SAC"],
  },
  6: {
    theme: "M√©t√©o",
    difficulty: "easy",
    gridSize: 8,
    words: ["PLUIE", "VENT", "NEIGE", "SOLEIL", "ORAGE", "GIVRE"],
  },
  7: {
    theme: "M√©tiers",
    difficulty: "medium",
    gridSize: 10,
    words: [
      "DOCTEUR",
      "AVOCAT",
      "GUIDE",
      "JUGE",
      "PILOTE",
      "POLICE",
      "CHEF",
      "VENDEUR",
      "ACTEUR",
    ],
  },
  8: {
    theme: "Sports",
    difficulty: "medium",
    gridSize: 10,
    words: [
      "TENNIS",
      "FOOT",
      "RUGBY",
      "JUDO",
      "BOXE",
      "GOLF",
      "SKI",
      "SURF",
      "VELO",
    ],
  },
  9: {
    theme: "Cuisine",
    difficulty: "medium",
    gridSize: 10,
    words: [
      "FOUR",
      "POELE",
      "MIXEUR",
      "COUPE",
      "BOL",
      "TASSE",
      "VERRE",
      "PLAT",
      "FOUET",
      "WOK",
    ],
  },
  10: {
    theme: "Transports",
    difficulty: "medium",
    gridSize: 10,
    words: [
      "TRAIN",
      "AVION",
      "METRO",
      "BUS",
      "TAXI",
      "BATEAU",
      "VELO",
      "MOTO",
      "AUTO",
    ],
  },
  11: {
    theme: "Corps Humain",
    difficulty: "medium",
    gridSize: 10,
    words: [
      "COEUR",
      "BRAS",
      "JAMBE",
      "TETE",
      "MAIN",
      "PIED",
      "NEZ",
      "YEUX",
      "DOS",
      "COU",
    ],
  },
  12: {
    theme: "Meubles",
    difficulty: "medium",
    gridSize: 10,
    words: [
      "TABLE",
      "CHAISE",
      "LIT",
      "SOFA",
      "BUREAU",
      "LAMPE",
      "TAPIS",
      "ARMOIRE",
      "BANC",
    ],
  },
  13: {
    theme: "Astronomie",
    difficulty: "hard",
    gridSize: 12,
    words: [
      "PLANETE",
      "ETOILE",
      "LUNE",
      "MARS",
      "VENUS",
      "TERRE",
      "SOLEIL",
      "COMETE",
      "GALAXIE",
      "ORBITE",
      "FUSEE",
      "ESPACE",
    ],
  },
  14: {
    theme: "Pays",
    difficulty: "hard",
    gridSize: 12,
    words: [
      "FRANCE",
      "CHINE",
      "JAPON",
      "BRESIL",
      "ITALIE",
      "ESPAGNE",
      "CANADA",
      "INDE",
      "MAROC",
      "EGYPTE",
      "GRECE",
      "PEROU",
    ],
  },
  15: {
    theme: "Sciences",
    difficulty: "hard",
    gridSize: 12,
    words: [
      "ATOME",
      "CHIMIE",
      "CELLULE",
      "VIRUS",
      "ROBOT",
      "LASER",
      "ENERGIE",
      "CLIMAT",
      "FOSSILE",
      "METAL",
      "ACIDE",
      "GAZ",
    ],
  },
  16: {
    theme: "Sentiments",
    difficulty: "hard",
    gridSize: 12,
    words: [
      "AMOUR",
      "JOIE",
      "PEUR",
      "COLERE",
      "HONTE",
      "ESPOIR",
      "FIERTE",
      "HAINE",
      "ENNUI",
      "CALME",
      "JALOUX",
      "TRISTE",
    ],
  },
  17: {
    theme: "Informatique",
    difficulty: "hard",
    gridSize: 12,
    words: [
      "CLAVIER",
      "SOURIS",
      "ECRAN",
      "WIFI",
      "CODE",
      "DATA",
      "BUG",
      "WEB",
      "LIEN",
      "PIXEL",
      "SERVER",
      "CLOUD",
      "APP",
      "JAVA",
    ],
  },
  18: {
    theme: "Arbres",
    difficulty: "hard",
    gridSize: 12,
    words: [
      "CHENE",
      "SAPIN",
      "ERABLE",
      "PIN",
      "BOULEAU",
      "POMMIER",
      "OLIVIER",
      "PALMIER",
      "SAULE",
      "FRENE",
      "HETRE",
      "CEDRE",
      "IF",
    ],
  },
};
let currentLevelId = 1;
let gridSize = 8;
let wordsToFind = [];
let foundWords = [];
let gridData = [];
let isDragging = !1;
let startCell = null;
let currentSelection = [];
let startTime = Date.now();
let timerInterval;
function loadLevel() {
  const savedLevel = localStorage.getItem("currentMotsMelesLevel");
  if (savedLevel) {
    try {
      const { levelId } = JSON.parse(savedLevel);
      const levelData = MOTS_MELES_LEVELS[levelId];
      if (levelData) {
        currentLevelId = levelId;
        gridSize = levelData.gridSize;
        wordsToFind = [...levelData.words];
        return;
      }
    } catch (e) {
      console.error("Erreur chargement niveau:", e);
    }
  }
  currentLevelId = 1;
  const defaultLevel = MOTS_MELES_LEVELS[1];
  gridSize = defaultLevel.gridSize;
  wordsToFind = [...defaultLevel.words];
  localStorage.setItem("currentMotsMelesLevel", JSON.stringify({ levelId: 1 }));
}
function generateGrid() {
  const grid = Array(gridSize)
    .fill(null)
    .map(() => Array(gridSize).fill(""));
  const directions = [
    [0, 1],
    [1, 0],
    [1, 1],
    [-1, 1],
  ];
  const placedWords = [];
  const wordsToPlace = [...wordsToFind].sort((a, b) => b.length - a.length);
  for (const word of wordsToPlace) {
    let placed = !1;
    let attempts = 0;
    const maxAttempts = 100;
    while (!placed && attempts < maxAttempts) {
      attempts++;
      const dir = directions[Math.floor(Math.random() * directions.length)];
      const startRow = Math.floor(Math.random() * gridSize);
      const startCol = Math.floor(Math.random() * gridSize);
      if (canPlaceWord(grid, word, startRow, startCol, dir)) {
        placeWord(grid, word, startRow, startCol, dir);
        placed = placedWords.push(word);
      }
    }
    if (!placed) {
      return generateGrid();
    }
  }
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      if (grid[r][c] === "") {
        grid[r][c] = alphabet[Math.floor(Math.random() * alphabet.length)];
      }
    }
  }
  gridData = grid;
}
function canPlaceWord(grid, word, r, c, dir) {
  let [dr, dc] = dir;
  if (
    r + dr * (word.length - 1) < 0 ||
    r + dr * (word.length - 1) >= gridSize ||
    c + dc * (word.length - 1) < 0 ||
    c + dc * (word.length - 1) >= gridSize
  ) {
    return !1;
  }
  for (let i = 0; i < word.length; i++) {
    const charAtGrid = grid[r + dr * i][c + dc * i];
    if (charAtGrid !== "" && charAtGrid !== word[i]) {
      return !1;
    }
  }
  return !0;
}
function placeWord(grid, word, r, c, dir) {
  let [dr, dc] = dir;
  for (let i = 0; i < word.length; i++) {
    grid[r + dr * i][c + dc * i] = word[i];
  }
}
function initGameInterface() {
  const gridElement = document.getElementById("motsMelesGrid");
  const wordsListElement = document.getElementById("wordsList");
  gridElement.innerHTML = "";
  wordsListElement.innerHTML = "";
  foundWords = [];
  gridElement.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
  for (let r = 0; r < gridSize; r++) {
    for (let c = 0; c < gridSize; c++) {
      const cell = document.createElement("div");
      cell.className = "grid-cell";
      cell.dataset.row = r;
      cell.dataset.col = c;
      cell.textContent = gridData[r][c];
      cell.addEventListener("mousedown", handleStart);
      cell.addEventListener("mouseenter", handleMove);
      cell.addEventListener("mouseup", handleEnd);
      cell.addEventListener("touchstart", handleStart, { passive: !1 });
      cell.addEventListener("touchmove", handleTouchMove, { passive: !1 });
      cell.addEventListener("touchend", handleEnd);
      gridElement.appendChild(cell);
    }
  }
  wordsToFind.forEach((word) => {
    const badge = document.createElement("div");
    badge.className = "word-item";
    badge.textContent = word;
    badge.dataset.word = word;
    wordsListElement.appendChild(badge);
  });
  document.addEventListener("mouseup", () => {
    if (isDragging) handleEnd();
  });
  updateStats();
}
function handleStart(e) {
  if (e.type === "touchstart") e.preventDefault();
  isDragging = !0;
  const target = e.target.closest(".grid-cell");
  if (!target) return;
  startCell = {
    row: parseInt(target.dataset.row),
    col: parseInt(target.dataset.col),
  };
  selectCell(target);
  currentSelection = [startCell];
}
function handleMove(e) {
  if (!isDragging) return;
  const target = e.target.closest(".grid-cell");
  if (!target) return;
  updateSelection(parseInt(target.dataset.row), parseInt(target.dataset.col));
}
function handleTouchMove(e) {
  if (!isDragging) return;
  e.preventDefault();
  const touch = e.touches[0];
  const target = document.elementFromPoint(touch.clientX, touch.clientY);
  if (target && target.classList.contains("grid-cell")) {
    updateSelection(parseInt(target.dataset.row), parseInt(target.dataset.col));
  }
}
function updateSelection(endRow, endCol) {
  const dr = endRow - startCell.row;
  const dc = endCol - startCell.col;
  if (dr === 0 || dc === 0 || Math.abs(dr) === Math.abs(dc)) {
    clearVisualSelection();
    currentSelection = [];
    const steps = Math.max(Math.abs(dr), Math.abs(dc));
    const stepR = dr === 0 ? 0 : dr / Math.abs(dr);
    const stepC = dc === 0 ? 0 : dc / Math.abs(dc);
    for (let i = 0; i <= steps; i++) {
      const r = startCell.row + i * stepR;
      const c = startCell.col + i * stepC;
      currentSelection.push({ row: r, col: c });
      const cell = document.querySelector(
        `.grid-cell[data-row="${r}"][data-col="${c}"]`,
      );
      if (cell) cell.classList.add("selected");
    }
  }
}
function handleEnd() {
  if (!isDragging) return;
  isDragging = !1;
  validateSelection();
  clearVisualSelection();
}
function clearVisualSelection() {
  document
    .querySelectorAll(".grid-cell.selected")
    .forEach((el) => el.classList.remove("selected"));
}
function selectCell(el) {
  el.classList.add("selected");
}
function validateSelection() {
  let word = "";
  currentSelection.forEach((pos) => {
    word += gridData[pos.row][pos.col];
  });
  const reversedWord = word.split("").reverse().join("");
  let validWord = null;
  if (wordsToFind.includes(word) && !foundWords.includes(word)) {
    validWord = word;
  } else if (
    wordsToFind.includes(reversedWord) &&
    !foundWords.includes(reversedWord)
  ) {
    validWord = reversedWord;
  }
  if (validWord) {
    foundWords.push(validWord);
    currentSelection.forEach((pos) => {
      const cell = document.querySelector(
        `.grid-cell[data-row="${pos.row}"][data-col="${pos.col}"]`,
      );
      cell.classList.add("found");
      cell.style.animation = "none";
      cell.offsetHeight;
      cell.style.animation = null;
    });
    const badge = document.querySelector(
      `.word-item[data-word="${validWord}"]`,
    );
    if (badge) badge.classList.add("found");
    updateStats();
    checkWin();
  }
}
function checkWin() {
  if (foundWords.length === wordsToFind.length) {
    clearInterval(timerInterval);
    const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
    saveProgress(currentLevelId, elapsedTime);
    setTimeout(() => {
      const nextLevelId = currentLevelId + 1;
      if (MOTS_MELES_LEVELS[nextLevelId]) {
        showSuccessPopupWordSearch(elapsedTime, nextLevelId);
      } else {
        showCompletionPopup();
      }
    }, 500);
  }
}
function saveProgress(levelId, time) {
  const storageKey = `motsMelesProgress_${CURRENT_USER_ID}`;
  const progress = JSON.parse(localStorage.getItem(storageKey) || "{}");
  if (!progress[levelId] || time < progress[levelId].bestTime) {
    progress[levelId] = { completed: !0, bestTime: time };
  }
  localStorage.setItem(storageKey, JSON.stringify(progress));
}
function updateStats() {
  document.getElementById("wordsFoundCount").textContent =
    `${foundWords.length}/${wordsToFind.length}`;
  if (document.getElementById("remainingWords")) {
    document.getElementById("remainingWords").textContent =
      wordsToFind.length - foundWords.length;
  }
}
function startTimer() {
  clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const minutes = Math.floor(elapsed / 60)
      .toString()
      .padStart(2, "0");
    const seconds = (elapsed % 60).toString().padStart(2, "0");
    const timerEl = document.getElementById("timer");
    if (timerEl) timerEl.textContent = `${minutes}:${seconds}`;
    const elapsedEl = document.getElementById("elapsedTime");
    if (elapsedEl) elapsedEl.textContent = `${minutes}:${seconds}`;
  }, 1000);
}
document.getElementById("hintBtn").addEventListener("click", () => {
  const remainingWords = wordsToFind.filter((w) => !foundWords.includes(w));
  if (remainingWords.length === 0) return;
  const randomWord = remainingWords[0];
  showPopup(`Cherchez le mot : ${randomWord}`, "Indice");
});
document.getElementById("restartBtn").addEventListener("click", () => {
  const restartAction = () => {
    startTime = Date.now();
    generateGrid();
    initGameInterface();
    startTimer();
  };
  const msg = "Voulez-vous vraiment recommencer ce niveau ?";
  if (typeof showConfirmPopup === "function") {
    showConfirmPopup(msg, restartAction);
  } else if (confirm(msg)) {
    restartAction();
  }
});
function loadLevelInfo() {
  const levelData = MOTS_MELES_LEVELS[currentLevelId];
  if (levelData) {
    const difficultyText =
      levelData.difficulty === "easy"
        ? "Facile"
        : levelData.difficulty === "medium"
          ? "Moyen"
          : "Difficile";
    const levelNumber =
      currentLevelId <= 6
        ? currentLevelId
        : currentLevelId <= 12
          ? currentLevelId - 6
          : currentLevelId - 12;
    document.getElementById("levelTitle").textContent =
      `${difficultyText} - Niveau ${levelNumber} : ${levelData.theme}`;
    const badge = document.querySelector(".level-badge");
    if (badge) {
      badge.classList.remove("easy", "medium", "hard");
      badge.classList.add(levelData.difficulty);
      const colors = {
        easy: { bg: "rgba(34, 197, 94, 0.2)", border: "#22c55e" },
        medium: { bg: "rgba(251, 191, 36, 0.2)", border: "#fbbf24" },
        hard: { bg: "rgba(239, 68, 68, 0.2)", border: "#ef4444" },
      };
      const style = colors[levelData.difficulty];
      badge.style.background = style.bg;
      badge.style.borderColor = style.border;
      badge.style.color = style.border;
    }
  }
}
document.addEventListener("DOMContentLoaded", async () => {
  await initSession();
  loadLevel();
  generateGrid();
  initGameInterface();
  startTimer();
  loadLevelInfo();
});
function calculateScore(difficulty, timeSeconds) {
  const basePoints = { easy: 500, medium: 800, hard: 1200 };
  let score = basePoints[difficulty] || 500;
  const timePenalty = timeSeconds * 2;
  score = Math.max(100, score - timePenalty);
  return Math.round(score);
}
function saveScore(gameType, levelId, difficulty, score, timeSeconds) {
  const storageKey = `gameScores_${CURRENT_USER_ID}`;
  const allScores = JSON.parse(localStorage.getItem(storageKey) || "{}");
  if (!allScores[gameType]) {
    allScores[gameType] = {
      totalPoints: 0,
      gamesPlayed: 0,
      gamesWon: 0,
      bestScores: {},
    };
  }
  const gameScores = allScores[gameType];
  gameScores.totalPoints += score;
  gameScores.gamesPlayed++;
  gameScores.gamesWon++;
  const levelKey = `${difficulty}_${levelId}`;
  if (
    !gameScores.bestScores[levelKey] ||
    score > gameScores.bestScores[levelKey].score
  ) {
    gameScores.bestScores[levelKey] = {
      score: score,
      time: timeSeconds,
      date: new Date().toISOString(),
    };
  }
  localStorage.setItem(storageKey, JSON.stringify(allScores));
  if (typeof envoyerScoreBDD === "function") {
    envoyerScoreBDD(gameType, levelId, difficulty, score, timeSeconds);
  }
  return {
    currentScore: score,
    totalPoints: gameScores.totalPoints,
    gamesWon: gameScores.gamesWon,
    isNewRecord:
      !gameScores.bestScores[levelKey] ||
      score === gameScores.bestScores[levelKey].score,
  };
}
async function envoyerScoreBDD(jeu, niveau, difficulte, score, temps) {
  try {
    await fetch("api/save_score.php", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ jeu, niveau, difficulte, score, temps }),
    });
  } catch (e) {
    console.error("Erreur API:", e);
  }
}
function showScoreInPopup(score, totalPoints, isNewRecord) {
  return `
          <div class="score-display">
              <div class="score-title">Score de la partie</div>
              <div class="score-main">${score} points</div>
              ${
                isNewRecord
                  ? '<div class="new-record">üèÜ Nouveau record !</div>'
                  : ""
              }
              <div class="score-total">Total : ${totalPoints} points</div>
          </div>
      `;
}
function showSuccessPopupWordSearch(elapsedTime, nextLevelId) {
  const minutes = Math.floor(elapsedTime / 60);
  const seconds = elapsedTime % 60;
  const levelData = MOTS_MELES_LEVELS[currentLevelId];
  const score = calculateScore(levelData.difficulty, elapsedTime);
  const scoreData = saveScore(
    "mots-meles",
    currentLevelId,
    levelData.difficulty,
    score,
    elapsedTime,
  );
  const popup = document.createElement("div");
  popup.className = "popup-overlay";
  popup.innerHTML = `
          <div class="popup-content success">
              <div class="popup-icon">üéâ</div>
              <h2>F√©licitations !</h2>
              <p>Vous avez trouv√© tous les mots !</p>
              
              ${showScoreInPopup(
                scoreData.currentScore,
                scoreData.totalPoints,
                scoreData.isNewRecord,
              )}
              
              <div class="popup-stats">
                  <div class="stat">
                      <i class="fa-solid fa-clock"></i>
                      <span>${minutes}m ${seconds}s</span>
                  </div>
                  <div class="stat">
                      <i class="fa-solid fa-font"></i>
                      <span>${wordsToFind.length} mots</span>
                  </div>
              </div>
              <div class="popup-buttons">
                  <button class="popup-btn primary" onclick="goToNextLevel(${nextLevelId})">
                      <i class="fa-solid fa-arrow-right"></i>
                      Niveau suivant
                  </button>
                  <button class="popup-btn secondary" onclick="closePopup()">
                      <i class="fa-solid fa-home"></i>
                      Retour aux niveaux
                  </button>
              </div>
          </div>
      `;
  document.body.appendChild(popup);
  setTimeout(() => popup.classList.add("show"), 10);
}
function showCompletionPopup() {
  const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
  const minutes = Math.floor(elapsedTime / 60);
  const seconds = elapsedTime % 60;
  const levelData = MOTS_MELES_LEVELS[currentLevelId];
  const score = calculateScore(levelData.difficulty, elapsedTime);
  const scoreData = saveScore(
    "mots-meles",
    currentLevelId,
    levelData.difficulty,
    score,
    elapsedTime,
  );
  const popup = document.createElement("div");
  popup.className = "popup-overlay";
  popup.innerHTML = `
          <div class="popup-content completion">
              <div class="popup-icon">üèÜ</div>
              <h2>Incroyable !</h2>
              <p>Vous avez termin√© tous les niveaux Mots M√™l√©s !</p>
              
              ${showScoreInPopup(
                scoreData.currentScore,
                scoreData.totalPoints,
                scoreData.isNewRecord,
              )}
              
              <div class="popup-stats">
                  <div class="stat">
                      <i class="fa-solid fa-clock"></i>
                      <span>${minutes}m ${seconds}s</span>
                  </div>
                  <div class="stat">
                      <i class="fa-solid fa-font"></i>
                      <span>${wordsToFind.length} mots</span>
                  </div>
              </div>
              <div class="popup-buttons">
                  <button class="popup-btn primary" onclick="closePopup()">
                      <i class="fa-solid fa-home"></i>
                      Retour aux niveaux
                  </button>
              </div>
          </div>
      `;
  document.body.appendChild(popup);
  setTimeout(() => popup.classList.add("show"), 10);
}
function closePopup() {
  const popup = document.querySelector(".popup-overlay");
  if (popup) {
    popup.classList.remove("show");
    setTimeout(() => {
      popup.remove();
      window.location.href = "mots-meles.html";
    }, 300);
  }
}
function goToNextLevel(nextLevelId) {
  localStorage.setItem(
    "currentMotsMelesLevel",
    JSON.stringify({ levelId: nextLevelId }),
  );
  location.reload();
}
